## URL para ser informada: https://github.com/alura-cursos/dash

# -*- coding: utf-8 -*-
"""
Script de Automação para Aplicações Dash.

Este script foi projetado para automatizar todo o processo de configuração e execução
de uma aplicação web feita com a biblioteca Dash a partir de um repositório Git.

Funcionalidades:
  - Criação e gerenciamento de um ambiente virtual Python ('env').
  - Instalação de dependências essenciais para Data Science.
  - Clonagem de um repositório Git fornecido pelo usuário.
  - Análise e correção automática (patching) de código-fonte para garantir
    compatibilidade com versões mais recentes das bibliotecas.
  - Execução do servidor da aplicação e abertura automática no navegador.

Autor: [Seu Nome]
Data: 26 de agosto de 2025
"""

import os
import subprocess
import sys
import logging
import webbrowser
import time
import shutil
import errno
import stat
from pathlib import Path
from typing import Tuple, Optional, List

# --- CONFIGURAÇÃO DO LOGGING ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    stream=sys.stdout,
)

# --- CONSTANTES ---
PASTA_VENV = Path('env')
PASTA_PROJETO_CLONADO = Path('projeto_exemplo_clonado')
PACOTES_MODERNOS = [
    'pandas', 'dash', 'dash-bootstrap-components', 'scikit-learn', 'xgboost', 'plotly'
]
NOMES_SCRIPT_APP = ['app.py', 'main.py']
URL_APP = 'http://127.0.0.1:8050'

# --- FUNÇÕES AUXILIARES DE BAIXO NÍVEL ---

def _executar_comando(comando: List[str], pasta_trabalho: Optional[Path] = None) -> bool:
    """
    Executa um comando de sistema em um subprocesso de forma segura.

    Args:
        comando (List[str]): O comando e seus argumentos em formato de lista.
        pasta_trabalho (Optional[Path]): O diretório onde o comando será executado.

    Returns:
        bool: True se o comando foi executado com sucesso, False caso contrário.
    """
    try:
        logging.info(f"Executando comando: {' '.join(comando)}")
        processo = subprocess.Popen(
            comando, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            text=True, encoding='utf-8', cwd=pasta_trabalho
        )
        _, stderr = processo.communicate()
        if processo.returncode != 0:
            logging.error(f"Falha ao executar comando: {' '.join(comando)}\n{stderr}")
            return False
        return True
    except FileNotFoundError:
        logging.error(f"Comando '{comando[0]}' não encontrado.")
        return False
    except Exception as e:
        logging.error(f'Erro inesperado ao executar o comando: {e}')
        return False

def confirmar_acao(mensagem: str) -> bool:
    """
    Exibe uma mensagem para o usuário e aguarda uma confirmação (s/n).

    Args:
        mensagem (str): A pergunta a ser exibida para o usuário.

    Returns:
        bool: True se o usuário confirmar, False caso contrário.
    """
    while True:
        try:
            resposta = input(f'{mensagem} (s/n): ').lower().strip()
            if resposta in ['s', 'sim', 'y', 'yes']: return True
            if resposta in ['n', 'nao', 'não', 'no']:
                logging.warning('Ação cancelada pelo usuário.')
                return False
            print('Resposta inválida. Por favor, digite "s" para sim ou "n" para não.')
        except KeyboardInterrupt:
            logging.warning('\nOperação interrompida pelo usuário.')
            sys.exit(1)

def obter_caminhos_plataforma() -> Tuple[Path, Path]:
    """
    Determina os caminhos corretos para os executáveis do Python e Pip no venv.

    Returns:
        Tuple[Path, Path]: Uma tupla contendo (caminho_python, caminho_pip).
    """
    if sys.platform == 'win32':
        executavel_python = PASTA_VENV / 'Scripts' / 'python.exe'
        executavel_pip = PASTA_VENV / 'Scripts' / 'pip.exe'
    else:
        executavel_python = PASTA_VENV / 'bin' / 'python'
        executavel_pip = PASTA_VENV / 'bin' / 'pip'
    return executavel_python, executavel_pip

def tratar_remocao_somente_leitura(funcao, caminho, info_excecao):
    """Callback para shutil.rmtree que lida com arquivos somente leitura."""
    valor_excecao = info_excecao[1]
    if funcao in (os.rmdir, os.remove, os.unlink) and valor_excecao.errno == errno.EACCES:
        os.chmod(caminho, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)
        funcao(caminho)
    else:
        raise

def corrigir_arquivo_app(caminho_arquivo: Path):
    """
    Analisa e aplica uma série de correções a um arquivo de aplicação Dash.
    
    Esta função é o "coração" da ferramenta, garantindo que código legado
    seja compatível com as versões mais recentes das bibliotecas.

    Args:
        caminho_arquivo (Path): O caminho para o arquivo app.py a ser corrigido.
    """
    logging.info(f"Verificando e corrigindo o arquivo '{caminho_arquivo}' para compatibilidade...")
    # ... (a lógica interna, por ser bem explicada pelos logs, não precisa de mais comentários)
    correcoes_feitas = 0
    try:
        conteudo = caminho_arquivo.read_text(encoding='utf-8')
        
        # Patch 1: Modernizar importações do Dash
        if 'import dash_core_components as dcc' in conteudo:
            conteudo = conteudo.replace('import dash_core_components as dcc', 'from dash import dcc, html').replace('import dash_html_components as html', '')
            correcoes_feitas += 1; logging.info('Patch aplicado: Importações do Dash modernizadas.')
            
        # Patch 2: Corrigir método obsoleto do Pandas
        if ".str.replace('.', '')" in conteudo:
            conteudo = conteudo.replace(".str.replace('.', '')", ".str.replace('.', '', regex=False)")
            correcoes_feitas += 1; logging.info('Patch aplicado: Comportamento do Pandas str.replace corrigido.')
            
        # Patch 3: Garantir que o layout exista
        if 'app.layout' not in conteudo:
            if 'from dash import html' not in conteudo and 'import dash_html_components as html' not in conteudo:
                if 'from dash import Dash' in conteudo: conteudo = conteudo.replace('from dash import Dash', 'from dash import Dash, html')
                else: conteudo = 'from dash import html\n' + conteudo
                correcoes_feitas += 1; logging.info('Patch aplicado: Adicionada importação "from dash import html".')
            conteudo += "\n\napp.layout = html.Div([html.H1('Aplicação Dash Inicializada'), html.P('Layout básico gerado.')])\n"
            correcoes_feitas += 1; logging.info('Patch aplicado: Inclusão de layout básico.')
            
        # Patch 4: Modernizar e garantir inicialização do servidor
        if 'app.run_server' in conteudo:
            conteudo = conteudo.replace('app.run_server', 'app.run')
            correcoes_feitas += 1; logging.info('Patch aplicado: "app.run_server" modernizado para "app.run".')

        if 'app.run_server' not in conteudo and 'app.run' not in conteudo:
            conteudo += f"\n\nif __name__ == '__main__':\n    app.run(debug=True, host='127.0.0.1', port={URL_APP.split(':')[-1]})\n"
            correcoes_feitas += 1; logging.info('Patch aplicado: Inclusão de app.run para manter servidor ativo.')
            
        if correcoes_feitas > 0:
            caminho_arquivo.write_text(conteudo, encoding='utf-8')
            logging.info(f'Total de {correcoes_feitas} correções aplicadas com sucesso!')
        else:
            logging.info('Nenhuma correção necessária.')
    except Exception as e:
        logging.error(f"Não foi possível corrigir o arquivo '{caminho_arquivo}': {e}")


# --- FASE 1: CRIAÇÃO E ESTRUTURAÇÃO DO AMBIENTE VIRTUAL ---
def configurar_ambiente_dash() -> Optional[Tuple[Path, Path]]:
    """
    Orquestra todas as etapas de configuração do ambiente de desenvolvimento.

    Verifica o Git, cria o ambiente virtual (venv) se necessário e instala
    as dependências listadas na constante PACOTES_MODERNOS.

    Returns:
        Optional[Tuple[Path, Path]]: Tupla com os caminhos dos executáveis
        (python, pip) em caso de sucesso, ou None em caso de falha.
    """
    logging.info('--- FASE 1: Configurando o Ambiente Virtual ---')
    # ... (lógica interna)
    if not shutil.which('git'):
        logging.error('O comando "git" não foi encontrado.')
        return None
    if not PASTA_VENV.is_dir():
        if confirmar_acao(f"O ambiente virtual '{PASTA_VENV}' não existe. Deseja criá-lo?"):
            if not _executar_comando([sys.executable, '-m', 'venv', str(PASTA_VENV)]): return None
            logging.info('Ambiente virtual criado com sucesso.')
        else: return None
    else: logging.info('Ambiente virtual já existente verificado.')
    executavel_python, executavel_pip = obter_caminhos_plataforma()
    logging.info('Instalando pacotes essenciais...')
    if not _executar_comando([str(executavel_pip), 'install'] + PACOTES_MODERNOS):
        logging.error('Falha ao instalar pacotes.')
        return None
    logging.info('Pacotes instalados com sucesso.')
    logging.info('--- Ambiente configurado com sucesso! ---')
    return executavel_python, executavel_pip

# --- FASE 2: EXEMPLO DE USO ---
def executar_exemplo_de_repositorio(executavel_python: Path):
    """
    Orquestra o processo de clonar, corrigir e executar uma aplicação Dash.

    Args:
        executavel_python (Path): O caminho para o executável Python do venv.
    """
    logging.info('\n--- FASE 2: Executando um Repositório ---')
    # ... (lógica interna)
    url = input('Informe a URL do repositório Git: ').strip()
    if not url.startswith('http'):
        logging.error('URL inválida.'); return
    if PASTA_PROJETO_CLONADO.exists():
        if not confirmar_acao(f"A pasta '{PASTA_PROJETO_CLONADO}' já existe. Deseja removê-la?"):
            logging.info('Clonagem cancelada.'); return
        shutil.rmtree(PASTA_PROJETO_CLONADO, onerror=tratar_remocao_somente_leitura)
    if not _executar_comando(['git', 'clone', url, str(PASTA_PROJETO_CLONADO)]): return
    logging.info('Repositório clonado com sucesso.')
    caminho_script_app = None
    for nome_script in NOMES_SCRIPT_APP:
        if (PASTA_PROJETO_CLONADO / nome_script).exists():
            caminho_script_app = PASTA_PROJETO_CLONADO / nome_script
            logging.info(f"Script da aplicação encontrado: '{nome_script}'"); break
    if not caminho_script_app:
        logging.error(f"Não foi possível encontrar script ({' ou '.join(NOMES_SCRIPT_APP)})."); return
    corrigir_arquivo_app(caminho_script_app)
    if not confirmar_acao(f"Tudo pronto. Deseja executar a aplicação '{caminho_script_app.name}'?"): return
    logging.info('--- Iniciando a aplicação web (Pressione CTRL+C para parar) ---')
    processo_servidor = None
    try:
        processo_servidor = subprocess.Popen([str(executavel_python), caminho_script_app.name], cwd=PASTA_PROJETO_CLONADO)
        time.sleep(5)
        webbrowser.open(URL_APP)
        processo_servidor.wait()
    except KeyboardInterrupt: logging.info('\nServidor encerrado pelo usuário.')
    except Exception as e: logging.error(f'Ocorreu um erro ao executar a aplicação: {e}')
    finally:
        if processo_servidor: processo_servidor.terminate(); processo_servidor.wait()
        logging.info('--- Servidor da aplicação finalizado ---')

# --- BLOCO PRINCIPAL DE EXECUÇÃO ---
if __name__ == '__main__':
    # FASE 1
    ambiente_configurado = configurar_ambiente_dash()
    
    # Se a FASE 1 foi bem sucedida, executa a FASE 2
    if ambiente_configurado:
        python_exec, _ = ambiente_configurado
        executar_exemplo_de_repositorio(python_exec)
    
    logging.info('Processo finalizado.')
